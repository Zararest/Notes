# Оглавление


# Межпроцедурный анализ

## Базовые концепции 

Граф вызовов - множество узлов и ребер, которым соответствуют процедуры программ и вызовы других процедур. При наличии указателей на функции и виртуальных функций одна точка вызова может соответствовать многим узлам. Для уменьшения количества потенциальных связей в таких точках применяется статическая аппроксимация возможных значений.

Строка вызовов - последовательность вызовов функций, которая привела анализатор в текущую точку. Она необходима напримре для анализа констант, поскольку их значение может зависеть от всех вызовов:

```cpp
for (i = 0; i < n; i++){

    t1 = g(0);
    t2 = g(243);
}

int g(int v){

    return f(v);
}

int f(int v){

    return v + 1;
}
```

Поскольку уровней вложенности произвольно много, применяется к-ограниченный контекстный анализ, где к - размер строки вызовов. При k = 0 анализ контекстно-нечувствительный.

Контекстно-чувствительный анализ на основе клогирования - метод анализа, при которомв каждой точке вызова создается новая независимая процедура с необходимыми параметрами. В этом случае возможно провести контекстно-независимый анализ.

Контекстно-чувствительный анализ на основе резюме - метод, при котором каждая функция характеризуется своим резюме. Оно описывает поведение функции и при анализе использкется уже готовая характеристика. Например при подстановке констант каждая процедура рассматривается как передаточная функция констант. При отсутситвии рекурсии каждую вызванную процедуру можно рассматривать ка вложенную область. Для получания наиболее точных результатов необходимо передавать констьанты вниз по областям. Также существует восходящая передача, которая позволяет строить функцию передачи. 

При наличии рекурсии мы сперва находим наиболее горячую точку графа вызовов и вычисляем все компоненты кроме горячих точек. Затем начинается вычисление сильно связных компонент до тех пор, пока не будет достигнута сходимость(обноаляем передаточные функции до тех пор, пока не лостигнем итерации с отсутствием изменений).

## Datalog
Datalog - язык для выражения логических выводов. Он состоит из атомов и заголовков. Заголовки обозначают производные от атомов и могут учавствовать в произведении других заголовков по правилам.

Заголовок истенен если истино тело.

Программа на этом языке применяется к набору входных данных до тех пор пока не будут сделаны все возможные выводы(истинные правила).

Пример вычисления путей в графе:

        path(X, Y) :- edge(X, Y)
        path(X, Y) :- path(X, Z) & path(Z, X)


По этим правилам и наборам вершин можно найти все пути в графе.

Экстенчиональная база данных - набор предикатов, которые определяются априори.

Интенсиональная база данных - набор выводов по праилам. 

Прдикат может принадлежать только одному из этих двух классов.

Выполнение такой программы заключается в подстановке всевозможных значений входных данных до тех пор пока не перестанут появляться новые правила. В примере с графами на каждом слкдующем шаге будут вычисляться все пути не более 2^(n - 1).

Очевидно, что на новом шаге будет новое предикат из праила, только в том случае, если в нем появится новый истинный предикат на прошлом шаге.

В некоторых случаях может быть выведено бесконечное количестов правил. В этом случае такие программы называются небезопасными(правила в заголовках которых находятся переменные, не появляющиеся в теле таким образом, чтобы онги могли принимать только экстенсивные значения) и нестратифицированные(множество правил, в котором есть рекурсия, включающая отрицание). 

## Контекстно-чувствительный анализ указателей 
Для построения контекстно-чувствительного анализа необходима информация о данных, с которыми работает программа в рассматриваемой точке. Чтобы наложить ограничения на переменные применяются методы клонирования и резюме
- Клонирование - разветвляет граф вызовов при обнаружении условного перехода, тем самым получая граф, в котором рассмотрены все возможные значения данных. (метод представлен исзодным методом и контекстом)
- Резюме - для каждой функции составляется формула, с помощью которой можно вычислить значение переменной в нужной точке.

Для построения таких представлений из графа вызовов удаляются все компоненты сильной связности(рекурсия). Таким образом можно  построить конечнуб строку вызовов.

# Подготовка к собесу
Контекстно свобюодная грамматика - такая грамматика, в которой при продукции слева стоит всегда один нетерминал. Она характеризуется:
1. мно-вом терминальных символов
2. мно-вом нетерминалов - мно-во строк терминалов
3. продукция состоящая из заголовка и тела 
4. стартовый нетерминал

Устранение левой рекурсии при рекурсивном спуске:

![Картинку укради цыгане](/images/1VPirH67kJs.jpg)

![Картинку укради цыгане](/images/NDeCXe2bQ9Q.jpg)

Язык - счетное множестов строк над некоторым фиксированным алфавитом. 
Основные действия над языком:
1. Объединение 
2. Конкатенация  
3. Замыкание Клини (можно получить конкатенацией языка с самим собой 0 и более раз)
4. Позитивное замыкание (тоже что и 3, но более 0 раз)

Регулярное выражение - описание языка, полученного рекурсивным объединением языков, полученных из подвыражений регулярного выражения. Индукция:

Есть 2 регулярных выражения, которые порождают языки L(r), L(s).
Для них определены операции:
1. (r) | (s) объединение языков 
2. (r)(s) конкатенация языков
3. (r)* замыкание Клини
4. (r) такой же язык

Язык, который может быть описан решулярным выражением называется регулярным.

Регулярные выражения представляют собой конечные автоматы. 
Контекстно свободные грамматики - автоматы со стеком.
Контекстно зависимые - машину Тьюринга.

Регулярные выражения не могут распознать {1^n 0^n} в то время как грамматика A -> 1A0 |e может

Недетерминированные колнечные автоматы - автоматы, которые не имеют ограничений на свои дуги. Входной символ может соответствовать сразу нескольким дугам.

Детерминированный конечный автомат - для каждого состояния и для каждого входного символа имеется только одна дуга. Для ДКА нет переходов для входа e.

Каждое регулярное выражение и каждый НКА могут бять преобразованы к ДКА

Общая идея построения ДКА их НКА. После чтения входной строки а_1..а_n ДКА находится в состоянии, соответствующем множеству состояний, которых мрожет достич НКА после чтения строки.

Построение НКА по регулярному выражению. Мы рекурсивно разбираем выражения и для каждой из 4 операций мы преобразуем НКА для подвыражений r и s

## LLVM
Глобальные символы - @ (глобальные переменные всегда указатели)
Локальные симаолы - % (метки и переменные)

```
define i32 @fib(i32) {              ;fib function
entry:
    %1 = icmp ult i32 %0, 2         ;нулевой параметр это аргумент функции
    br i1 %1, label %final, label %st

st:  
    %2 = add i32 %0, -1 
    %3 = call i32 @fib(i32 %2)
    %4 = add i32 %0, -2
    %5 = call i32 @fib(i32 %4)
    %6 = add i32 %3, %5
    br label %final

final: 
    %7 = phi i32 [%6, %st], [1, %entry]
    ret i32 %7
}

```
Базовый блок - последовательность инструкций, заканчивающаяся терминатором. 

phi узел - место где сходятся инструкции: %10 = phi i32 [*что хотим взять* *с какой метки*], [...], ...

Инструкции:
1. <result> = add <ty> <op1>, <op2>
2. <result> = icmp <cond> <ty> <op1>, <op2>
3. %1 = load i32, i32* %idx (работает только по указателям)
4. store i32 %1, i32* mem 
5. <result> = getelementptr <ty>, <ty>* <ptrval> {, <ty> <idx>} * (надо разыменовывать сам глобальный указатель)
%arrafirst = i32* getelementptr [10 x i32], [10 x i32]* @arr i64 0, i64 1 (нумерация с нуля)

Интринсик - функция, встроенная в компилятор. Например 
`call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0)`

В нодах LLVM лежат метаданные. Они нужны для оптимизирующих компиляторов.

После SSA представления код уходит на виртуальные ркгистры, оптимизируется и потом правильно распределяется на ркальные ркгистры.
