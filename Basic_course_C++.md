# Введение #
Этот документ представляет собой конспект лекций базового курса МФТИ по C++.
---
# Список тем курса #
- Лекция 3
    * Ссылки и указатели
    * lvalue и rvalue
    * using и cdecl
    * Манглирование 
    * Разрешение имен
    * Пространства имен
- Лекция 4
    * Инициалзация
    * Делегация конструкторов
    * RVO
    * Конструктор копирования
    * Квалификации 
    * Пользовательские преобразования
- Лекция 5
    * Владение ресурсами
    * RAI
    * Оператор *
    * Оператор ->
    * rvalue
    * std::move()
    * Аннотация методов
    * Возврат ссылок
    * Конструктор перемещения
    * Реализация std::swap()
    * Правило пяти 
    * Правило нуля
- Лекция 6
    * Статические функции
    * noexcept
    * Селекторы
    * Прокси
    * unique_ptr
    * Приведение типов
    * Strict aliasing violation
    * Арифметика
    * Унарный плюс
    * Операторы вне класса
- Лекция 7
    * Функторы
    * Pimpl
    * Проход по контейнеру
    * Переопределение бинарных операторов
    * Побитовый сдвиг
    * Тривалентное сравнение


## Лекция 3 ##

### Ссылки и указатели ###
Константные ссылки продлевают время жизни временного объекта. Время жизни таких объектов длится до конца полного выражения. Пример провисания ссылки в структуре:

```cpp
struct S {

    int x;
    const int& y;
};

S x{1, 2}; //ссылка не провисла, потому что был создан постоянный объект на стеке
S* ptr = new S{1, 2}; //ссылка провисла, так как был создан временный объект, и конец полного выражения наступил до присваивания   
```

Возвращение константных ссылок из функций может привести к провисанию. 

### lvalue и rvalue ###
В отличие от lvalue у rvalue нету постоянного места в памяти.

```cpp
int& foo();
foo() = x; //верное выражение, поскольку функция может возвращать ссылку на выделенную память
```

### using и cdecl ###
Чтение типов: идем вправо, затем влево и в конце выходим из скобок. Пример:

```cpp
int *x[20]; //массив указателей на int
int (*y)[20]; //указатель на массив int
int (&z)[20] = *y; //ссылка на массив
```

Для упрощения объявлений используется ключевое слово using:

```cpp
using ptr_to_func_ref = void (*) (int&) //вместо звездочки имя функции

template <typename T>
using ptr_to_func_ref = void (*) (T&); //набор указателей на функцию 
```

### Манглирование ###
Манглирование - процесс искажения имен при переводе языка в ассемблер. При отсутствии манглирования возможно создание API, с помощью которых возможно общение программ на разных языках. 

Из-за гарантии по именам в С невозможно:
1. перегружать функции
2. получать методы классов(структур)
3. получить шаблон 

Для получения стабильного имени в C++ используется:

```cpp
extern "C" double sqrt(double); //для этой функции невозможны перегрузки и namespace
```

### Разрешение имен ###
При разрешении имен выбираются кандидаты, подходящие по сигнатуре. После этого из них выбирается нужный по правилам:
1. Точное совпадение(int -> int; int -> const int&, ...)
2. Точное совпадение с шаблоном(int -> T)
3. Стандартное преобразование(int -> char, float -> unsigned short)
4. Пользовательские преобразования
5. Объекты с переменным числом аргументов
6. Неправильно связанные ссылки

### Пространства имен ###
Пространство имен добавляет манглрование к каждому объекту, входящему в него. Пространство имен можно переоткрывать для добавления туды сущностей:

```cpp
namespace X{
    int foo(); //добавление функции в пространство имен X
}   

using std::vector; //добавление сущности в текущее пространство имен
using namespace X; //добавление всех объектов из X 
```

Анонимные пространства имен

```cpp
namespace { //создался namespace с уникальным именем и сразу был вызван using

    int foo(){

        return 42;
    }
}

int bar() { return foo(); } //внутри текущего модуля можно вызывать foo
```

Правила работы с namespace:
* Не засорять глобальное пространство именем
* Не писать using namespace в заголовочных файлах
* Использовать анонимные пространства имен вместо статических функций(не для классов)
* не использовать анонимные пространства имен в заголовочных файлах

Функция main не манглируется. 

## Лекция 4 ##

### Инициалзация ###
В парсере С++ есть два важных правила:
* Все, что может быть засчитано за объявление функции, является объявлением функции.
* Все, что может считаться обращением к полю, считается обращением к полю.

Пример:

```cpp
struct list_t {}

struct myClass_t {
    int x = 42;

    myClass_t(list_t, list_t){} // конструктор
};

int main(){

    myClass_t m1(list_t(), list_t()); //считается за определение функции
    myClass_t m2{list_t(), list_t()}; //вызов конструктора
}
```

Пример разных видов инициализации:
```cpp
int n; //default-init n = garbage
int m{}; //value-init m = 0
int m = 0;//copy-init

int* p = new int[5]{}; //аналог calloc
```
Для пользовательских классов такие инициализации без параметров одинаковые.

Список инициализации выполняется до тела конструктора. Даже если он пустой, для каждого объекта класса вызывается сначала дефолтнный конструктор или инициализатор, описанный в теле класса. Список инициализации выполняется в том порядке, в котором в классе объявлены поля.

### Делегация конструкторов ###
Если в классе есть несколько нетривиальных конструкторов, то можно вызывать их в списке инициализации других.

```cpp
struct class_c{

    int max = 0, min = 0;

    class_c(int my_max) : max(my_max > 0 ? my_max : DEFAULT_MAX){}

    class_c(int my_max, int my_min) : class_c(my_max), min(42){}
}
```

Делегированный конструктор идет первым в списке инициализации.

### RVO ###
RVO - return value optimizations.

У конструктора копирования и оператора присваивания есть спецсемантика. После выполнения этих функций надо объектами они становятся полностью эквивалентными.

```cpp
foo bar(){ 
    foo local_foo;
    return local_foo;
}

int main(){
    foo f = bar(); //в этом случае не будет вызван оператор присваивания или конструктор копирования
}
```

RVO происходят до оптимизации, поэтому не важно, что происходит в конструкторе копирования и операторе присваивания.

### Конструктор копирования ###
Поскольку конструктор копирования обладает спецсемантикой, у него должна быть одна из форм:

```cpp
struct Copyable{

    Copyable(const Copyable& c);
};
```
Допустимо также принимать неконстантную ссылку, как угодно cv-квалифицированную ссылку или значение.

Конструктор копирования не может быть шаблонным. Пример, когда конструктор копирования будет сгенерирован компилятором: 

```cpp
template <typename T> struct Coercible{

    template <typename U> Coercible(const Coercible<U>& c){} //это не конструктор копирования 
};
```

В этом случае должно быть так:

```cpp
template <typename T> struct Coercible{

    Coercible(const Coercible& c)
};
```

### Квалификации ###
Есть два специальных квалификатора const и volatile
* const - объект не может быть изменен 
* volatile - объект может произвольно измениться между двумя обращениями к нему 
* const volatile - программа не может записать туда значение, но оно может непредсказуемо измениться

### Пользовательские преобразования ###

Можно добавить неявное преобразование типов. Их можно рассматривать как конструкторы. Пример:

```cpp
struct MyString{

    char* buf;
    size_t len;

    MyString(size_t len) : buf_{new char[len]{}, len_{len}} {} //пользовательское преобразование 
};

void foo(MyString);

foo(42); //работает тк было неявное преобразование 
```

Для избежания ненужных неявных преобразований применяется ключевое слово `explicit`.

`explicit` блокирует copy-init:

```cpp
struct Foo{

    explicit Foo(int x){}
};

Foo f{2}; //прямая инициализация сработает
Foo f = 2; //инициализация копированием не сработает 
```

Для преобразований пользовательского класса к другому типу существует оператор преобразования:

```cpp
struct MyString {

    char* buf_; 
    size_t len_;
    
    operator const char*(){ return buf_; } //оператор преобразования из MyString в char* 
};
```

Поскольку может возникнуть конфликт операторов для двух пользовательских классов(в каждом определены пользовательские преобразования в другой), есть разница между copy-init и direct-init:

```cpp
int main(){ 

    Bar b;
    Foo f1{b}; //тут рассматриваются только конструкторы
    Foo f2 = b; //рассматриваются только неявные конструкторы и операторы преобразования
}
```

## Лекция 5 ##

### Владение ресурсами ###
Владеет ресурсом тот, кто его выделяет и освобождает. Пример класса, инвариант которого это владение ресурсом:

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    ScopedPointer(T * ptr = nullptr) : ptr_(ptr){} //этот класс имеет неявное преобразование от обычного указателя к этому
    ~ScopedPointer(){ delete ptr_; }
}
```

Если в каком-то месте необходим ScopePointer, а мы передаем туда обычный указатель, то из-за звездочки рядом с типом будет создан ScopePointer.

### RAI ###
RAI - resource acquisition is initialization(захват ресурса это инициализация). Инвариант такого класса это уникальность владения ресурсом.

### Оператор * ###

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    ScopedPointer(T * ptr = nullptr) : ptr_(ptr){}
    ~ScopedPointer(){ delete ptr_; }

    T& operator *(){ return *ptr_; }             //этот оператор может быть только внутри класса
    const T& operator *() const{ return *ptr_; }
}
```

### Оператор -> ###

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    T& operator *(){ return *ptr_; }             
    const T& operator *() const{ return *ptr_; }

    T* operator ->(){ return ptr_; } //поскольку этот оператор имеет drill down behavior, этот же оператор будет вызван для T*
    const T* operator  ->() const{ return ptr_; }
}
```

В данном случаем вызов оператора `->` можно представить как:

```cpp
(p.operator ->())->x; //доступ к полю x типа T
```

### rvalue ###
rvalue - само выражение, которое не имеет места в памяти(например х + 1).

Ссылка на rvalue - операция создания объекта со значением выражения.

```cpp
int&& y = x + 1; //сам y является lvalue, но обозначает место в памяти, которое выделилось под выражение
```

Правая ссылка не может быть связана с lvalue:

```cpp
int x = 1;
int&& y = x + 0; //можно
int&& z = x;     //нельзя
```

Неконстантная левая ссылка не может быть связана с rvalue:

```cpp
int& c = x + 1;      //нельзя 
const int& z = x +1; //можно, но это исключение для константной ссылки
```

Сама по себе правая ссылка является lvalue:

```cpp
int&& y = x + 1;
int&& e = y; //нельзя 
int& f = y;  //можно
```

### std::move ###

```cpp
int&& y = std::move(x); //можно воспринимать как простое приведение типов(теперь у одного и того же места в памяти два имени: x, y)
```

Пример работы std::move():

```cpp
ScopePointer y {new int(10)};
ScopePointer b = std::move(y); //тут произошло перемещение состояния из y в b
assert(y == b);              
```

Assert иногда выполнится иногда нет, так как после оператора перемещения временный объект приходит в консистентное непредсказуемое состояние.

После вызова std::move() на y мы можем его переиспользовать и вызывать его методы, потому что знаем, что инвариант класса не нарушен и освобождение пройдет правильно.

### Аннотации методов ###
Поскольку методы можно вызывать от временных объектов, возникают ситуации, когда результат работы этих методов провисает:

```cpp
struct S{

    int n = 0;
    int& access(){ return n; }
};

S x;
int& y =  x.access();
int& z = S{}.access(); //в этом случае ссылка провисла 
```

В данном случае это произошло, потому что у временного объекта закончилось время жизни в конце полного выражения.

Чтобы избежать таких ситуаций существуют аннотации методов:

```cpp
struct S{

    int foo() &;  //может быть вызван только у lvalue объектов 
    int foo() &&; //перегрузка методов по аннотации 
};
```

Для аксессеров надо аннотировать методы:

```cpp
struct S{

    int n = 0;
    int& access() & { return n; }
};

int& z = S{}.access(); //ошибка компиляции 
```

Пример rvalue аннотации:

```cpp
class X{

    vector<char> data_;

public:

    X() = default;
    vector<char> const & data() const & { return data_; }
    vector<char>&& data() && { return std::move(data_); } //в этом случае для временных объектов возвращается временный объект
};
```

### Возврат ссылок ###
Варианты возвращения ссылок:

```cpp
int& foo(int x&){ return x; } //в этом случае не провиснет, но если возвращать ссылку на объект объявленный в функции, то точное провисание
const int& bar(const int& x){ return x; } //если сюда был подан временный объект(bar(x + 1)), то его время жизни продлено на стековом фрейме функции bar(), поэтому провисание 
int&& buz(int&& x){ return std::move(x); } //всегда провисла 
```

Правые ссылки надо возвращать только из && аннотированных методов.

Если из вашего метода возвращается правая ссылка, то вы:
- либо пишите std::move(), std::forward(), std::decl_val()
- либо метод && аннотирован 
- либо вы делаете что-то неправильно 

### Конструктор перемещения ###
Такой конструктор передаёт владение от временного объекта к новому:

```cpp
template <typename T>
class ScopePointer{

    T* ptr_;

public: 

    ScopePointer(const ScopePointer& rhs) : ptr_(new T{*rhs.ptr_}) {} // конструктор копирования(у типа T тоже есть конструктор копирования)
    ScopePointer(ScopePointer&& rhs) : ptr_(rhs.ptr_) { //переместили состояние временного объекта

        rhs.ptr_ = nullptr;
    }
};
```

Аналогично действует перемещающее присваивания. Он оставляет временный объект в консистентном, но необязательно предсказуемом состоянии. 

### Реализация std::swap() ###

```cpp
template <typename T>
void swap(T& x, T& y){

    T tmp = std::move(x);
    x = std::move(y);
    y = std::move(tmp);
}
```

В первой строчке std::move() сделал временный объект, который имеет состояние x. Потом перемещающий оператор присваивания забрал его и поместил в tmp. Аналогично переместились состояния y и tmp.

Если в классе нет перемещающего конструктора, то std::move() привел объект x к временному объекту. Затем вызовется копирующий конструктор, так как это copy-init.

### Правило пяти ###
Если ваш класс требует нетривиального определения(в том числе = delete) хотя бы одного из пяти методов:
1. копирующего конструктора
2. копирующего присваивания
3. перемещающего конструктора
4. перемещающего присваивания
5. деструктора

то нужно нетривиально определить все пять.

### Правило нуля ###
Если ваш класс требует нетривиального определения хотя бы одного из пяти неявных методов, и, таким образом все пять, то в нем не должно быть других методов.

Другими словами Либо класс управляет своей памятью, либо не требует нетривиальных методов.

## Лекция 6 ##

### Статические функции ###
Статическая функция - такая функция, в которую неявно не подается *this. Она работает с самим классом, а не с его объектом. Статические функции находятся в пространстве имен класса.

### noexcept ###
Если в методе нет сложной работы с данными, то на него можно повесить аннотацию noexcept. Это значит, что из метода не может вылететь исключение. Пример:

```cpp
Matrix(Mayrix&& rhs) noexcept;
Matrix& operator =(Matrix&& rhs) noexcept; //поскольку тут только меняются указатели можно повесить
```

###  Селекторы ###
Селекторы - методы возвращающие информацию о классе. Пример:

```cpp
template <typename T>
class Matrix{

public:

    int ncols() const;
    int nrows() const;

    bool equal(const Matrix& other);
};
```

### Прокси ###
Прокси класс - класс, который захватывает состояние класса, перегружает некие операторы и с их помощью а=выстраивает правильное поведение. Пример:

```cpp
template <typename T>
class Matrix{

    struct ProxyRow{

        T* row;
        const T& operator [](int n) const{ return row[n]; }
        T& operator [](int n){ return row[n]; }
    }
public:

    ProxyRow operator [](int);
};
```

### unique_ptr ###
unique_ptr - идеальный RAI класс. В ScopePointer делалось предположение, что захваченный ресурс возможно скопировать, но это не всегда возможно сделать. 

```cpp
unique_ptr(unique_ptr& rhs) = delete;

unique_ptr(unique_ptr&& rhs) : ptr_(rhs_.ptr){

    rhs.ptr_ = nullptr;
}

unique_ptr& operator =(unique_ptr&& rhs){

    swap(*this, rhs);
    return *this;
}
```

Создание unique_ptr: 

```cpp
auto res = std::make_unique<MyRes>(x,y); //x, y - аргументы конструктора класса MyRes

if (...){

    bar(std::move(res)); //корректная передача ресурса в другую функцию(мы можем только перемещать unique_ptr)
    return 1;
}
```

Внутри функции `std::make_unique<MyRes>(x,y)` выделяется память под этот объект.

```cpp
const unique_ptr<MyRes> p{new MyRes(x,y)}; //тут мы даже не можем вызвать перемещение
```

### Приведение типов ###

```cpp
x = static_cast<int>(y); //обычные безопасные преобразования 
int* q - const_cast<int*>(p); //снятие константности
long long uq = reinterpret_cast<long long>(q); //например приведение int* к lon long 
```

Такие приведения лучше Сишных версий через () тем, что каждый из этих кастов отвечает за свои приведения.

reinterpret_cast - трактует все биты в памяти как другой тип без их преобразования. 
static_cast - меняет побитовое значение в памяти. Он пытается наиболее хорошо сохранить семантическое значение. Для собственных классов явные преобразования определяются конструкторами от одного аргумента другого типа:

```cpp
struct T {};

struct S{ 
    explicit S(T){}
};

foo(T); //FAIL
foo(static_cast<S>(T)); //OK
```

### Strict aliasing violation ###
Strict aliasing violation - UB, заключающийся в том, что lvalue не может быть одновременно адресован указателями разных типов. Пример:

```cpp
float p = 1.0;
int n = *reinterpret_cast<int*>(&p); //привели указатель на float к указателю на int 
```

Решение:

```cpp
int m = std::bit_cast<int>(p); //делает std::memcpy()
```

### Арифметика ###

```cpp
unsigned short x = 0xFFFE, y = 0xEEEE; //x * y = 0xEEEC2224
unsigned short v = x * y;              //v = 0x2224 тк unsigned это арифметика по модулю 2^n
unsigned w = x * y;                    //w = 0xEEEC2224
unsigned long long z = x * y;          //z = 0xFFFFFEEEC2224
```

Если что-то может быть приведено к signed int, оно приводится к signed int. При перемножении каждое число было приведено к int, а потом реинтерпретированно к нужному значению. 

### Унарный плюс ###
Это легальный способ приведения к встроенному типу:

```cpp
struct Foo{

    operator long(){ return 42; } //из нашего типа к long
};

void foo(int x);
void foo(Foo x);

Foo f;
foo(f); //вызов foo(Foo)
Foo(+f);//вызов foo(int) через приведение к long
```

### Операторы вне класса ###
Можно определить оператор вне класса и в классе одновременно. Вне класса оператор не будет иметь доступ к закрытым полям, но может быть вызван так же как оператор в классе. Если в классе определен оператор, то будет вызываться всегда он, а не операторы вне класса. Пример:

```cpp
struct Quat{

    int x, y, z, i;

    Quat operator -() const{

        return Quat{-x, -y, -z, -i};
    }
};

Quat operator -(const Quat& arg){

    return Quat{-arg.x, - arg.y, - arg.z, - arg.i};
}
```

## Лекция 7 ##

### Функторы ###
Во многих случаях C++ работает быстрее С из-за переопределенных операторов, которые могут быть заинлайнены, в то время как в С при вызове компаратора происходит переход по указателю на функцию.(указатели на функции не подставляются)

В некоторых случаях невозможно перегрузить оператор(например для инт), поэтому можно передавать функции подобный объект, который может быть заинлайнен. Пример:

```cpp
struct gt{

    static bool gtf(int x, int y){ return x > y; }
    using gtfptr_t = bool (*)(int, int); //для приведения к указателю на функцию(вместо звездочки будет имя функции)
    operator gtfptr_t() const { return gtf(x, y); } //оператор неявного преобразования к указателю на функцию 
};

std::sort(myarr.begin(), myarr.end(), gt{}); //объект функтора будет неявно преобразован к функции 
```

В этом примере произойдет инлайн, потому что в `std::sort` утек правильный тип gt.

Помимо этого можно перегрузить у функтора оператор ():

```cpp
struct gt{

    bool operator ()(int x, int y){ return x > y; }  
};
```

### Pimpl ###
Pimpl - Pointer to implementation. Эта идиома позволяет иметь класс с одинаковым размером вне зависимости от реализации:

```cpp
class Ifacade{

    CImpl* impl_; //ссылка на класс с реализацией
public:

    Ifacade() : impl_(new CImpl){}
};
```

В такой реализации этот класс стал RAI классом, поэтому надо реализовать все конструкторы и операторы. Чтобы этого избежать надо заменить указатель на unique_ptr.

Для unique_ptr необходимо определение класса:

```cpp
class MyClass;

struct MyWraper{

    MyClass* c; //нормально 
};

struct MySafeWraper{

    unique_ptr<MyClass> c; //не сработает тк не определен MyClass
};
```

Это происходит из-за того, что в unique_ptr один из шаблонных параметров это делетер. До того как определен класс неизвестно сколько памяти он занимает, поэтому и нельзя определить unique_ptr. 

Чтобы это исправить нужно объявить делетер и реализовать его там, где будет известен размер класса(после реализации):

```cpp
class MyClass;

struct MyClassDeleter{

    void operator ()(MyClass* obj);
};

struct MySafeWraper{

    unique_ptr<MyClass, MyClassDeleter> c;
    MySafeWraper() : c(nullptr){}         //просто конструктор
};
```

### Проход по контейнеру ###
Преинкремент возвращает новое значение, поэтому в нем не происходит копирование объекта как в постикременте, поэтому обход контейнера делается так:

```cpp
for (iter it = cont.begin(), ite = cont.end(); it != ite; ++it){

}
```

### Переопределение бинарных операторов ###
Разница между определением в классе и вне класса:

```cpp
struct Quat{

    int x_, y_, z_, i_;

    Quat(int x = 0, int y = 0, int z = 0, int i = 0) : x_(x), y_(y), z_(z), i_(i){} //поскольку есть значения по умолчанию, возможно преобразование из int в quat

    Quat& operator +=(const Quat& rhs){

        x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_; i_ += rhs.i_;
    }

    Quat operator +(const Quat& rhs){ 
        
        Quat tmp(*this);
        tmp += rhs;
        return tmp;
    }
};

Quat p = q + 1; //можно
Quat w = 1 + 1; //нельзя
```

Чтобы это исправить надо определить оператор вне класса в терминах +=.

Если в классе много неявных преобразований, то возможна ситуация когда внешний бинарный оператор может вызываться где не должен:

```cpp
struct S{

    S(std::string){}
    S(std::wstring){}
};

bool operator()(S lhs, S rhs){ return true; }

assert(string{"foo"} == std::string{L "bar"}); //будет true
```

В этом случае было вызвано неявное преобразование, а затем внешний оператор ==.

### побитовый сдвиг ###
При выводе в поток данных `<<` это перегруженный побитовый сдвиг. Пример переопределения:

```cpp
template <typename T>
struct Quat{

    T x, y, z, i;

    void dump(std::ostream& os) const{

        os << x << " " << y << " " << z << " " << i;   
    }
};

template <typename T>
std::ostream& operator <<(std::ostream& os, const Quat<T>& q){

    q.dump(os);
    return os;
}
```

### Тривалентное сравнение ###
Такое сравнение, которое возвращает 3 аргумента(как strcmp). Для этого есть специальный оператор, который можно перегрузить и на его основе компилятор автоматически сгенерирует все бинарные операторы сравнения:

```cpp
int main(){

    int a = 4, b = 4, c = 5;
    auto ac = (a <=> c); //тривалентное сравнение 
    std::cut << (ac < 0) << std::endl;  //true
} 
```

Равенство надо писать. Этот оператор возвращает ordering type.