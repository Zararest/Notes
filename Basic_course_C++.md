# Введение #
Этот документ представляет собой конспект лекций базового курса МФТИ по C++.
---
# Список тем курса #
- Лекция 3
    * Ссылки и указатели
    * lvalue и rvalue
    * using и cdecl
    * Манглирование 
    * Разрешение имен
    * Пространства имен
- Лекция 4
    * Инициалзация
    * Делегация конструкторов
    * RVO
    * Конструктор копирования
    * Квалификации 
    * Пользовательские преобразования
- Лекция 5
    * Владение ресурсами
    * RAI
    * Оператор *
    * Оператор ->
    * rvalue
    * std::move()
    * Аннотация методов
    * Возврат ссылок
    * Конструктор перемещения
    * Реализация std::swap()
    * Правило пяти 
    * Правило нуля
- Лекция 6
    * Статические функции
    * noexcept
    * Селекторы
    * Прокси
    * unique_ptr
    * Приведение типов
    * Strict aliasing violation
    * Арифметика
    * Унарный плюс
    * Операторы вне класса
- Лекция 7
    * Функторы
    * Pimpl
    * Проход по контейнеру
    * Переопределение бинарных операторов
    * Побитовый сдвиг
    * Тривалентное сравнение
- Лекция 8
    * ParaCL
    * Отличие =default и пустого деструктора
    * Наследование
    * Приведение типов
    * Circle and ellipse problem
    * Принцип подстановки Лисков
    * Проблема срезки(начальная версия)
    * Полиморфизм 
    * Виртуальные функции   
    * Чисто виртуальные методы
    * Виртуальный деструктор
    * Интерфейсные классы
    * Виртуальное копирование
    * Проблема срезки 
    * Правильный класс
    * EBCO
    * Pure virtual function call
    * Связывание 
    * NVI
    * Виды полиморфизма 
    * Приватное наследование
    * Protected наследование
    * Отличие struct от class
- Лекция 9
    * Ромбовидные схемы
    * Виртуальное наследование
    * Конструкторы
    * Преобразования 
    * RTTI
    * dynamic_cast
    * Регулярные выражения
    * Регулярные выражения в С++
    * Детерминированный конечный автомат
    * Недетерминированный конечный автомат
    * FLEX
    * Лемма о накачке
- Лекция 10
    * Грамматика
    * Автоматы с магазинной памятью 
    * Таксономия L\R
    * Рекурсивный спуск
    * LL(1) парсер
    * LR(k) парсер


## Лекция 3 ##

### Ссылки и указатели ###
Константные ссылки продлевают время жизни временного объекта. Время жизни таких объектов длится до конца полного выражения. Пример провисания ссылки в структуре:

```cpp
struct S {

    int x;
    const int& y;
};

S x{1, 2}; //ссылка не провисла, потому что был создан постоянный объект на стеке
S* ptr = new S{1, 2}; //ссылка провисла, так как был создан временный объект, и конец полного выражения наступил до присваивания   
```

Возвращение константных ссылок из функций может привести к провисанию. 

### lvalue и rvalue ###
В отличие от lvalue у rvalue нету постоянного места в памяти.

```cpp
int& foo();
foo() = x; //верное выражение, поскольку функция может возвращать ссылку на выделенную память
```

### using и cdecl ###
Чтение типов: идем вправо, затем влево и в конце выходим из скобок. Пример:

```cpp
int *x[20]; //массив указателей на int
int (*y)[20]; //указатель на массив int
int (&z)[20] = *y; //ссылка на массив
```

Для упрощения объявлений используется ключевое слово using:

```cpp
using ptr_to_func_ref = void (*) (int&) //вместо звездочки имя функции

template <typename T>
using ptr_to_func_ref = void (*) (T&); //набор указателей на функцию 
```

### Манглирование ###
Манглирование - процесс искажения имен при переводе языка в ассемблер. При отсутствии манглирования возможно создание API, с помощью которых возможно общение программ на разных языках. 

Из-за гарантии по именам в С невозможно:
1. перегружать функции
2. получать методы классов(структур)
3. получить шаблон 

Для получения стабильного имени в C++ используется:

```cpp
extern "C" double sqrt(double); //для этой функции невозможны перегрузки и namespace
```

### Разрешение имен ###
При разрешении имен выбираются кандидаты, подходящие по сигнатуре. После этого из них выбирается нужный по правилам:
1. Точное совпадение(int -> int; int -> const int&, ...)
2. Точное совпадение с шаблоном(int -> T)
3. Стандартное преобразование(int -> char, float -> unsigned short)
4. Пользовательские преобразования
5. Объекты с переменным числом аргументов
6. Неправильно связанные ссылки

### Пространства имен ###
Пространство имен добавляет манглрование к каждому объекту, входящему в него. Пространство имен можно переоткрывать для добавления туды сущностей:

```cpp
namespace X{
    int foo(); //добавление функции в пространство имен X
}   

using std::vector; //добавление сущности в текущее пространство имен
using namespace X; //добавление всех объектов из X 
```

Анонимные пространства имен

```cpp
namespace { //создался namespace с уникальным именем и сразу был вызван using

    int foo(){

        return 42;
    }
}

int bar() { return foo(); } //внутри текущего модуля можно вызывать foo
```

Правила работы с namespace:
* Не засорять глобальное пространство именем
* Не писать using namespace в заголовочных файлах
* Использовать анонимные пространства имен вместо статических функций(не для классов)
* не использовать анонимные пространства имен в заголовочных файлах

Функция main не манглируется. 

## Лекция 4 ##

### Инициалзация ###
В парсере С++ есть два важных правила:
* Все, что может быть засчитано за объявление функции, является объявлением функции.
* Все, что может считаться обращением к полю, считается обращением к полю.

Пример:

```cpp
struct list_t {}

struct myClass_t {
    int x = 42;

    myClass_t(list_t, list_t){} // конструктор
};

int main(){

    myClass_t m1(list_t(), list_t()); //считается за определение функции
    myClass_t m2{list_t(), list_t()}; //вызов конструктора
}
```

Пример разных видов инициализации:
```cpp
int n; //default-init n = garbage
int m{}; //value-init m = 0
int m = 0;//copy-init

int* p = new int[5]{}; //аналог calloc
```
Для пользовательских классов такие инициализации без параметров одинаковые.

Список инициализации выполняется до тела конструктора. Даже если он пустой, для каждого объекта класса вызывается сначала дефолтнный конструктор или инициализатор, описанный в теле класса. Список инициализации выполняется в том порядке, в котором в классе объявлены поля.

### Делегация конструкторов ###
Если в классе есть несколько нетривиальных конструкторов, то можно вызывать их в списке инициализации других.

```cpp
struct class_c{

    int max = 0, min = 0;

    class_c(int my_max) : max(my_max > 0 ? my_max : DEFAULT_MAX){}

    class_c(int my_max, int my_min) : class_c(my_max), min(42){}
}
```

Делегированный конструктор идет первым в списке инициализации.

### RVO ###
RVO - return value optimizations.

У конструктора копирования и оператора присваивания есть спецсемантика. После выполнения этих функций надо объектами они становятся полностью эквивалентными.

```cpp
foo bar(){ 
    foo local_foo;
    return local_foo;
}

int main(){
    foo f = bar(); //в этом случае не будет вызван оператор присваивания или конструктор копирования
}
```

RVO происходят до оптимизации, поэтому не важно, что происходит в конструкторе копирования и операторе присваивания.

### Конструктор копирования ###
Поскольку конструктор копирования обладает спецсемантикой, у него должна быть одна из форм:

```cpp
struct Copyable{

    Copyable(const Copyable& c);
};
```
Допустимо также принимать неконстантную ссылку, как угодно cv-квалифицированную ссылку или значение.

Конструктор копирования не может быть шаблонным. Пример, когда конструктор копирования будет сгенерирован компилятором: 

```cpp
template <typename T> struct Coercible{

    template <typename U> Coercible(const Coercible<U>& c){} //это не конструктор копирования 
};
```

В этом случае должно быть так:

```cpp
template <typename T> struct Coercible{

    Coercible(const Coercible& c)
};
```

### Квалификации ###
Есть два специальных квалификатора const и volatile
* const - объект не может быть изменен 
* volatile - объект может произвольно измениться между двумя обращениями к нему 
* const volatile - программа не может записать туда значение, но оно может непредсказуемо измениться

### Пользовательские преобразования ###

Можно добавить неявное преобразование типов. Их можно рассматривать как конструкторы. Пример:

```cpp
struct MyString{

    char* buf;
    size_t len;

    MyString(size_t len) : buf_{new char[len]{}, len_{len}} {} //пользовательское преобразование 
};

void foo(MyString);

foo(42); //работает тк было неявное преобразование 
```

Для избежания ненужных неявных преобразований применяется ключевое слово `explicit`.

`explicit` блокирует copy-init:

```cpp
struct Foo{

    explicit Foo(int x){}
};

Foo f{2}; //прямая инициализация сработает
Foo f = 2; //инициализация копированием не сработает 
```

Для преобразований пользовательского класса к другому типу существует оператор преобразования:

```cpp
struct MyString {

    char* buf_; 
    size_t len_;
    
    operator const char*(){ return buf_; } //оператор преобразования из MyString в char* 
};
```

Поскольку может возникнуть конфликт операторов для двух пользовательских классов(в каждом определены пользовательские преобразования в другой), есть разница между copy-init и direct-init:

```cpp
int main(){ 

    Bar b;
    Foo f1{b}; //тут рассматриваются только конструкторы
    Foo f2 = b; //рассматриваются только неявные конструкторы и операторы преобразования
}
```

## Лекция 5 ##

### Владение ресурсами ###
Владеет ресурсом тот, кто его выделяет и освобождает. Пример класса, инвариант которого это владение ресурсом:

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    ScopedPointer(T * ptr = nullptr) : ptr_(ptr){} //этот класс имеет неявное преобразование от обычного указателя к этому
    ~ScopedPointer(){ delete ptr_; }
}
```

Если в каком-то месте необходим ScopePointer, а мы передаем туда обычный указатель, то из-за звездочки рядом с типом будет создан ScopePointer.

### RAI ###
RAI - resource acquisition is initialization(захват ресурса это инициализация). Инвариант такого класса это уникальность владения ресурсом.

### Оператор * ###

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    ScopedPointer(T * ptr = nullptr) : ptr_(ptr){}
    ~ScopedPointer(){ delete ptr_; }

    T& operator *(){ return *ptr_; }             //этот оператор может быть только внутри класса
    const T& operator *() const{ return *ptr_; }
}
```

### Оператор -> ###

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    T& operator *(){ return *ptr_; }             
    const T& operator *() const{ return *ptr_; }

    T* operator ->(){ return ptr_; } //поскольку этот оператор имеет drill down behavior, этот же оператор будет вызван для T*
    const T* operator  ->() const{ return ptr_; }
}
```

В данном случаем вызов оператора `->` можно представить как:

```cpp
(p.operator ->())->x; //доступ к полю x типа T
```

### rvalue ###
rvalue - само выражение, которое не имеет места в памяти(например х + 1).

Ссылка на rvalue - операция создания объекта со значением выражения.

```cpp
int&& y = x + 1; //сам y является lvalue, но обозначает место в памяти, которое выделилось под выражение
```

Правая ссылка не может быть связана с lvalue:

```cpp
int x = 1;
int&& y = x + 0; //можно
int&& z = x;     //нельзя
```

Неконстантная левая ссылка не может быть связана с rvalue:

```cpp
int& c = x + 1;      //нельзя 
const int& z = x +1; //можно, но это исключение для константной ссылки
```

Сама по себе правая ссылка является lvalue:

```cpp
int&& y = x + 1;
int&& e = y; //нельзя 
int& f = y;  //можно
```

### std::move ###

```cpp
int&& y = std::move(x); //можно воспринимать как простое приведение типов(теперь у одного и того же места в памяти два имени: x, y)
```

Пример работы std::move():

```cpp
ScopePointer y {new int(10)};
ScopePointer b = std::move(y); //тут произошло перемещение состояния из y в b
assert(y == b);              
```

Assert иногда выполнится иногда нет, так как после оператора перемещения временный объект приходит в консистентное непредсказуемое состояние.

После вызова std::move() на y мы можем его переиспользовать и вызывать его методы, потому что знаем, что инвариант класса не нарушен и освобождение пройдет правильно.

### Аннотации методов ###
Поскольку методы можно вызывать от временных объектов, возникают ситуации, когда результат работы этих методов провисает:

```cpp
struct S{

    int n = 0;
    int& access(){ return n; }
};

S x;
int& y =  x.access();
int& z = S{}.access(); //в этом случае ссылка провисла 
```

В данном случае это произошло, потому что у временного объекта закончилось время жизни в конце полного выражения.

Чтобы избежать таких ситуаций существуют аннотации методов:

```cpp
struct S{

    int foo() &;  //может быть вызван только у lvalue объектов 
    int foo() &&; //перегрузка методов по аннотации 
};
```

Для аксессеров надо аннотировать методы:

```cpp
struct S{

    int n = 0;
    int& access() & { return n; }
};

int& z = S{}.access(); //ошибка компиляции 
```

Пример rvalue аннотации:

```cpp
class X{

    vector<char> data_;

public:

    X() = default;
    vector<char> const & data() const & { return data_; }
    vector<char>&& data() && { return std::move(data_); } //в этом случае для временных объектов возвращается временный объект
};
```

### Возврат ссылок ###
Варианты возвращения ссылок:

```cpp
int& foo(int x&){ return x; } //в этом случае не провиснет, но если возвращать ссылку на объект объявленный в функции, то точное провисание
const int& bar(const int& x){ return x; } //если сюда был подан временный объект(bar(x + 1)), то его время жизни продлено на стековом фрейме функции bar(), поэтому провисание 
int&& buz(int&& x){ return std::move(x); } //всегда провисла 
```

Правые ссылки надо возвращать только из && аннотированных методов.

Если из вашего метода возвращается правая ссылка, то вы:
- либо пишите std::move(), std::forward(), std::decl_val()
- либо метод && аннотирован 
- либо вы делаете что-то неправильно 

### Конструктор перемещения ###
Такой конструктор передаёт владение от временного объекта к новому:

```cpp
template <typename T>
class ScopePointer{

    T* ptr_;

public: 

    ScopePointer(const ScopePointer& rhs) : ptr_(new T{*rhs.ptr_}) {} // конструктор копирования(у типа T тоже есть конструктор копирования)
    ScopePointer(ScopePointer&& rhs) : ptr_(rhs.ptr_) { //переместили состояние временного объекта

        rhs.ptr_ = nullptr;
    }
};
```

Аналогично действует перемещающее присваивания. Он оставляет временный объект в консистентном, но необязательно предсказуемом состоянии. 

### Реализация std::swap() ###

```cpp
template <typename T>
void swap(T& x, T& y){

    T tmp = std::move(x);
    x = std::move(y);
    y = std::move(tmp);
}
```

В первой строчке std::move() сделал временный объект, который имеет состояние x. Потом перемещающий оператор присваивания забрал его и поместил в tmp. Аналогично переместились состояния y и tmp.

Если в классе нет перемещающего конструктора, то std::move() привел объект x к временному объекту. Затем вызовется копирующий конструктор, так как это copy-init.

### Правило пяти ###
Если ваш класс требует нетривиального определения(в том числе = delete) хотя бы одного из пяти методов:
1. копирующего конструктора
2. копирующего присваивания
3. перемещающего конструктора
4. перемещающего присваивания
5. деструктора

то нужно нетривиально определить все пять.

### Правило нуля ###
Если ваш класс требует нетривиального определения хотя бы одного из пяти неявных методов, и, таким образом все пять, то в нем не должно быть других методов.

Другими словами Либо класс управляет своей памятью, либо не требует нетривиальных методов.

## Лекция 6 ##

### Статические функции ###
Статическая функция - такая функция, в которую неявно не подается *this. Она работает с самим классом, а не с его объектом. Статические функции находятся в пространстве имен класса.

### noexcept ###
Если в методе нет сложной работы с данными, то на него можно повесить аннотацию noexcept. Это значит, что из метода не может вылететь исключение. Пример:

```cpp
Matrix(Mayrix&& rhs) noexcept;
Matrix& operator =(Matrix&& rhs) noexcept; //поскольку тут только меняются указатели можно повесить
```

###  Селекторы ###
Селекторы - методы возвращающие информацию о классе. Пример:

```cpp
template <typename T>
class Matrix{

public:

    int ncols() const;
    int nrows() const;

    bool equal(const Matrix& other);
};
```

### Прокси ###
Прокси класс - класс, который захватывает состояние класса, перегружает некие операторы и с их помощью а=выстраивает правильное поведение. Пример:

```cpp
template <typename T>
class Matrix{

    struct ProxyRow{

        T* row;
        const T& operator [](int n) const{ return row[n]; }
        T& operator [](int n){ return row[n]; }
    }
public:

    ProxyRow operator [](int);
};
```

### unique_ptr ###
unique_ptr - идеальный RAI класс. В ScopePointer делалось предположение, что захваченный ресурс возможно скопировать, но это не всегда возможно сделать. 

```cpp
unique_ptr(unique_ptr& rhs) = delete;

unique_ptr(unique_ptr&& rhs) : ptr_(rhs_.ptr){

    rhs.ptr_ = nullptr;
}

unique_ptr& operator =(unique_ptr&& rhs){

    swap(*this, rhs);
    return *this;
}
```

Создание unique_ptr: 

```cpp
auto res = std::make_unique<MyRes>(x,y); //x, y - аргументы конструктора класса MyRes

if (...){

    bar(std::move(res)); //корректная передача ресурса в другую функцию(мы можем только перемещать unique_ptr)
    return 1;
}
```

Внутри функции `std::make_unique<MyRes>(x,y)` выделяется память под этот объект.

```cpp
const unique_ptr<MyRes> p{new MyRes(x,y)}; //тут мы даже не можем вызвать перемещение
```

### Приведение типов ###

```cpp
x = static_cast<int>(y); //обычные безопасные преобразования 
int* q - const_cast<int*>(p); //снятие константности
long long uq = reinterpret_cast<long long>(q); //например приведение int* к lon long 
```

Такие приведения лучше Сишных версий через () тем, что каждый из этих кастов отвечает за свои приведения.

reinterpret_cast - трактует все биты в памяти как другой тип без их преобразования. 
static_cast - меняет побитовое значение в памяти. Он пытается наиболее хорошо сохранить семантическое значение. Для собственных классов явные преобразования определяются конструкторами от одного аргумента другого типа:

```cpp
struct T {};

struct S{ 
    explicit S(T){}
};

foo(T); //FAIL
foo(static_cast<S>(T)); //OK
```

### Strict aliasing violation ###
Strict aliasing violation - UB, заключающийся в том, что lvalue не может быть одновременно адресован указателями разных типов. Пример:

```cpp
float p = 1.0;
int n = *reinterpret_cast<int*>(&p); //привели указатель на float к указателю на int 
```

Решение:

```cpp
int m = std::bit_cast<int>(p); //делает std::memcpy()
```

### Арифметика ###

```cpp
unsigned short x = 0xFFFE, y = 0xEEEE; //x * y = 0xEEEC2224
unsigned short v = x * y;              //v = 0x2224 тк unsigned это арифметика по модулю 2^n
unsigned w = x * y;                    //w = 0xEEEC2224
unsigned long long z = x * y;          //z = 0xFFFFFEEEC2224
```

Если что-то может быть приведено к signed int, оно приводится к signed int. При перемножении каждое число было приведено к int, а потом реинтерпретированно к нужному значению. 

### Унарный плюс ###
Это легальный способ приведения к встроенному типу:

```cpp
struct Foo{

    operator long(){ return 42; } //из нашего типа к long
};

void foo(int x);
void foo(Foo x);

Foo f;
foo(f); //вызов foo(Foo)
Foo(+f);//вызов foo(int) через приведение к long
```

### Операторы вне класса ###
Можно определить оператор вне класса и в классе одновременно. Вне класса оператор не будет иметь доступ к закрытым полям, но может быть вызван так же как оператор в классе. Если в классе определен оператор, то будет вызываться всегда он, а не операторы вне класса. Пример:

```cpp
struct Quat{

    int x, y, z, i;

    Quat operator -() const{

        return Quat{-x, -y, -z, -i};
    }
};

Quat operator -(const Quat& arg){

    return Quat{-arg.x, - arg.y, - arg.z, - arg.i};
}
```

## Лекция 7 ##

### Функторы ###
Во многих случаях C++ работает быстрее С из-за переопределенных операторов, которые могут быть заинлайнены, в то время как в С при вызове компаратора происходит переход по указателю на функцию.(указатели на функции не подставляются)

В некоторых случаях невозможно перегрузить оператор(например для инт), поэтому можно передавать функции подобный объект, который может быть заинлайнен. Пример:

```cpp
struct gt{

    static bool gtf(int x, int y){ return x > y; }
    using gtfptr_t = bool (*)(int, int); //для приведения к указателю на функцию(вместо звездочки будет имя функции)
    operator gtfptr_t() const { return gtf(x, y); } //оператор неявного преобразования к указателю на функцию 
};

std::sort(myarr.begin(), myarr.end(), gt{}); //объект функтора будет неявно преобразован к функции 
```

В этом примере произойдет инлайн, потому что в `std::sort` утек правильный тип gt.

Помимо этого можно перегрузить у функтора оператор ():

```cpp
struct gt{

    bool operator ()(int x, int y){ return x > y; }  
};
```

### Pimpl ###
Pimpl - Pointer to implementation. Эта идиома позволяет иметь класс с одинаковым размером вне зависимости от реализации:

```cpp
class Ifacade{

    CImpl* impl_; //ссылка на класс с реализацией
public:

    Ifacade() : impl_(new CImpl){}
};
```

В такой реализации этот класс стал RAI классом, поэтому надо реализовать все конструкторы и операторы. Чтобы этого избежать надо заменить указатель на unique_ptr.

Для unique_ptr необходимо определение класса:

```cpp
class MyClass;

struct MyWraper{

    MyClass* c; //нормально 
};

struct MySafeWraper{

    unique_ptr<MyClass> c; //не сработает тк не определен MyClass
};
```

Это происходит из-за того, что в unique_ptr один из шаблонных параметров это делетер. До того как определен класс неизвестно сколько памяти он занимает, поэтому и нельзя определить unique_ptr. 

Чтобы это исправить нужно объявить делетер и реализовать его там, где будет известен размер класса(после реализации):

```cpp
class MyClass;

struct MyClassDeleter{

    void operator ()(MyClass* obj);
};

struct MySafeWraper{

    unique_ptr<MyClass, MyClassDeleter> c;
    MySafeWraper() : c(nullptr){}         //просто конструктор
};
```

### Проход по контейнеру ###
Преинкремент возвращает новое значение, поэтому в нем не происходит копирование объекта как в постикременте, поэтому обход контейнера делается так:

```cpp
for (iter it = cont.begin(), ite = cont.end(); it != ite; ++it){

}
```

### Переопределение бинарных операторов ###
Разница между определением в классе и вне класса:

```cpp
struct Quat{

    int x_, y_, z_, i_;

    Quat(int x = 0, int y = 0, int z = 0, int i = 0) : x_(x), y_(y), z_(z), i_(i){} //поскольку есть значения по умолчанию, возможно преобразование из int в quat

    Quat& operator +=(const Quat& rhs){

        x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_; i_ += rhs.i_;
    }

    Quat operator +(const Quat& rhs){ 
        
        Quat tmp(*this);
        tmp += rhs;
        return tmp;
    }
};

Quat p = q + 1; //можно
Quat w = 1 + 1; //нельзя
```

Чтобы это исправить надо определить оператор вне класса в терминах +=.

Если в классе много неявных преобразований, то возможна ситуация когда внешний бинарный оператор может вызываться где не должен:

```cpp
struct S{

    S(std::string){}
    S(std::wstring){}
};

bool operator()(S lhs, S rhs){ return true; }

assert(string{"foo"} == std::string{L "bar"}); //будет true
```

В этом случае было вызвано неявное преобразование, а затем внешний оператор ==.

### побитовый сдвиг ###
При выводе в поток данных `<<` это перегруженный побитовый сдвиг. Пример переопределения:

```cpp
template <typename T>
struct Quat{

    T x, y, z, i;

    void dump(std::ostream& os) const{

        os << x << " " << y << " " << z << " " << i;   
    }
};

template <typename T>
std::ostream& operator <<(std::ostream& os, const Quat<T>& q){

    q.dump(os);
    return os;
}
```

### Тривалентное сравнение
Такое сравнение, которое возвращает 3 аргумента(как strcmp). Для этого есть специальный оператор, который можно перегрузить и на его основе компилятор автоматически сгенерирует все бинарные операторы сравнения:

```cpp
int main(){

    int a = 4, b = 4, c = 5;
    auto ac = (a <=> c); //тривалентное сравнение 
    std::cut << (ac < 0) << std::endl;  //true
} 
```

Равенство надо писать. Этот оператор возвращает ordering type.


## Лекция 8 ##

## ParaCL ###
Базовый синтаксис:

```cpp
fst = 0; //все типы int
snd = 1;
iters = ?; //считывание со stdin число 

while (iters > 0){ //синтаксис if аналогичный

    tmp = fst; //тут новая переменная 
    fst = snd; 
    snd = snd + tmp;
    iters = iters - 1;
}

print snd; //вывод на stdout
```
Лексер разбивает файл на поток лексем.

Парсер строит синтаксическое дерево.

### Отличие =default и пустого деструктора ###
В union дефолтный деструктор это отсутствие деструктора, поэтому, прописав =default будет ошибка компиляции, так как деструктор должен быть у всего.

В данном случае =default ===delete.

```cpp
union U{

    std::string s_;
    std::vector<int> v_;
    U(std::string s){ new (&s_) std::string{s}; } //создать на месте 
    U(std::vector<int> v){ new (&v_) std::vector<int>{v}; }
    ~U() {}
};
```

Память должен освобождать пользователь.

### Наследование ###
Публичное наследование реализует идею "В является А"(is-a):

```cpp
class A {};
class B : public A {}; //B is also A
```

У открытого наследования есть два смысла:
- В расширяет А
- В является частным случаем А

Конструктор:

```cpp
struct Node{

    Node* parent;
    Node_t type_;
};

struct BinOp : public Node{

    BinOp_t op_;
    Node* lhs_ = nullptr;
    Node* rhs_ = nullptr;

    BinOp(Node* parent, BinOp_t opcode) : Node{parent, Node_t::BINOP}, op_(opcode) {}
};
```

### Приведение типов ###
Для родителей и детей:

```cpp
struct Node;
struct BinOP : public Node;

void foo(const Node& pn);

BinOp* b = new BinOp(p, op);
foo(*b);                    //принимает тк BinOp is a Node
Node* pn = b;               //даже не нужен статик каст 
b = static_cast<BinOp*>(pn);//нужен статик каст
```

### Circle and ellipse problem ###
Может возникнуть ситуация когда два смысла наследования противоречат друг другу. Наприме не понятно наследовать квадрат от прямоугольника или прямоугольник от квадрата. Если возникает такая проблема, то лучше не наследоваться вообще.

### Принцип подстановки Лисков ###
Типы Base и Derived связаны отношением is-a, если любой истинный предикат, интересующий нас, относительно Base остается истинным при подстановке Derived. 

### Проблема срезки(начальная версия) ###

```cpp
struct A{
    int a_;
    A(int a) : a_(a) {}
};

struct B : public A{
    int b_;
    B(int b) : A(b / 2) b_(b) {}
};

B b1(10);
B b2(8);

A& a_ref = b2;
a_ref = b1;    //b2.a = 5; b2.b = 8
```

В этом случае из-за того, что вызвался оператор присваивания для типа А, присвоилось только поле a.

### Полиморфмизм ###
Функция называется полиморфной, если она ведет себя по-разному в зависимости от аргументов. 

### Виртуальные функции ###
Виртуальные функции позволяют вызывать методы дочерних классов по указателю на базовый. ССылки на нужные функции хранятся в таблице виртуальных функций, которая лежит где-то в памяти в рантайме. Её создает конструктор базового класса, а каждый из потомков инициализирует ее собственными методами. Таблица виртуальных функций считается сконструированной только в конце конструктора.

overriding - при совпадении имени функции с именем виртуальной функции родительского класса.

overloading - переопределение функции родителя.

Статический тип - тип известный на этапе компиляции(может отличаться от типа объекта, который будет передан в эту функцию).

Динамический тип - тип при конкретном вызове(может быть любым наследником статического типа). Этот тип определяется через таблицу виртуальный функций.

Статический полиморфизм - полиморфизм шаблонных функций.

Динамический полиморфизм - полиморфизм виртуальных функций. 

Пример, когда функция не попала в таблицу виртуальных функций из-за перегрузки:

```cpp
struct Matrix{
    virtual void pow(int x);
};

struct SpareMatrix : Matrix{
    void pow(long x); //из-за несовпадения типов случилось переопределение
}
```

Для избежания таких ситуаций b}есть ключевое слово override, которое означает "никогда не overload". С этим ключевым словом необязательно писать virtual.

Конструкторы не могут быть виртуальными.

### Чисто виртуальные методы ###
Чисто виртуальный метод - такой метод, который должны оверрайдить все наследники. Класс с хотя бы одним чисто виртуальным методом не может быть создан.

### Виртуальный деструктор ###
Виртуальный деструктор предназначен для уничтожения объектов производного класса по указателю на базовый класс.

Чисто виртуальный деструктор должен иметь тело. 

### Интерфейсные классы ###
Интерфейсным классом называется класс, в котором все методы чисто виртуальные. Также называется абстрактным базовым классом. 

### Виртуальное копирование ###
Чтобы скопировать весь объект по указателю на базовый класс, надо добавить метод clone():

```cpp
struct ISquare{

    virtual ISquare* clone() const = 0;
}; 

template <typename T>
struct Triangle : public Isquare{

    std::array<Point<T>, 3> pts_;
    Triangle* clone() const override{ return new Triangle{pts_}; }; //законный оверрайд
}
```

### Проблема срезки ###
При передаче объекта по значению теряется виртуальное поведение:

```cpp
struct A{

    int a_;
    A(int a) : a_(a) {};
    virtual void dump(std::ostream& os) const { os << a_; }
    virtual ~A() {}
};

struct B : public A {
    int b_;
    B(int b) : A(b / 2), b_{b} {}
    void dump(std::ostream& os) const override { os << a_ << b_; }
};

std::ostream& operator <<(std::ostream& os, const A& a) {

    a.dump(os);
    return os;
}

void foo(A a){

    std::cout << a << std::endl; //будет напечатано только a_
}

void bar(A& a){

    std::cout << a << std::endl; //будет напечатано и а_ и b_
}

int main(){

    B b1(10);
    foo(b1);
    bar(b1);
}
```

### Правильный класс ###
Класс написан правильно, если выполнено одно из:
- класс содержит виртуальный деструктор
- класс final
- класс stateless
- класс содержит protected деструктор 

### EBCO ###
EBCO - empty base class optimizations. Если базовый класс пустой, то размер базовой части класса в наследнике равен нулю.

Это может быть полезно например в unique_ptr. Этот класс с учетом делетера становится в два раза больше из-за наличия ссылки на делетер. Если отнаследоваться от делетера(этот класс пустой и содержит только оператор круглые скобки), то размер базовой части будет 0 и размер unique_ptr равен размеру указателя:

```cpp
template <typename T, typensmr Deleter =  default_deleter<T>> //немного не так но идея правильная
class unique_ptr : private Deleter {

    T* ptr_;
public:

    unique_ptr(T* ptr = nullptr, Deleter del = Deleter()) : Deleter(del), ptr_(ptr) {}
    ~unique_ptr() { Deleter::operator ()(ptr_); }
};
```

### Pure virtual function call ###
Эта ошибка возникает при вызове чисто виртуального метода в конструкторе или функции, вызванной из конструкора. Пример:

```cpp
struct Base{

    Base(){ doIt(); } //виртуальная таблица готова только к концу конструктора, поэтому виртуальная функция не вызовется 
    virtual void doIt() = 0;//компиялтор пытается девиртуализовать doIt() 
};

struct Derived : public Base{

    void doIt() override;
};

int main(){

    Derived d;
}
```

В данном случае это ошибка компиляции, но если мы вызоыем функцию doIt2(), в которой вызовем doIt(), у нас 
будет ошибка в рантайме.

В общем случае мы можем вызывать методы в конструкторе только в final классах, чтобы не случилось PVC.

Любой вызов из конструктора и деструктора не виртуальный.

### Связывание ###
Обычные функции связываются статически. Виртуальные функции связываются динамически(во время рантайма для вызова функции происходит переход по ссылке)

Аргументы по умолчанию связываются статически(зависят от статического типа объекта):

```cpp
struct Base{
    virtual int foo(int a = 14){ return a; }
};

struct Derived{
    int foo(int a = 42) override { return a; }
}

Base* pb = new Derived{};
std::cout << pb->foo() << std::endl; //на экране будет 14 тк статичкеский тип это base(но исполнится функция Derived)
```

### NVI ###
NVI - non virtual interface.

Это сделано для возможности использования аргументов по умолчапнию.

```cpp
struct BaseNVI {

    int foo(int x = 42) { return foo_impl(x); }
private:
    virtual int foo_impl(int a) { return a; }      //override может вытаскивать из private в public
};

struct Derived : public Base{
    int foo_inpl(int a) override { return a; }
}
```

В этом случае будет вызвана невиртуапльная функция, а реализация будет виртуальной.

### Виды полиморфизма ###
Есть два вида полиморфизма: статический и динамический.

- множество перегрузки можно рассматривать как статически полиморфную функцию.
- шаблон функции это статически полиморфная функция.
- виртуальная функция это динамически полиморфная функция по неявному аргументу this.

Можно перегружать виртуальные функции. Пример:

```cpp
struct Matrix{

    virtual void pow(int x);
    virtual void pow(double y);
};

struct SpareMatrix : public Matrix{

    using Matrix::pow;//усли этого не будет, то всегда по ссылке на SpareMatrix будет вызываться pow(int) тк сначала проверяются все функции
    //в текущем namespace и только потом в базовом классе 
    void pow(int x) override; 
}
```

### Приватное наследование ###
Такое наследование реализует отношение part of. Все поля становятся приватными.

Помимо закрытого наследования отношения part of может быть сделано как:

```cpp
class Whole : private Part{ //закрытое наследование

};

class Whole{//композиция

private:
    Part p_;
}
```

Отличия:
- при наследовании можно переопределять виртуапльные функции из базового класса.
- доступ к protected полям
- возможность использовать using и вводить имена из базового класса

### Protected наследование ###
Все поля становятся protected.

### Отличие struct от class ###
В классе по умолчанию все поля private и наследование тоже private.

В структуре по умолчанию все поля public и наследование тоже public.

## Лекция 9 ##

### Ромбовидные схемы ###
При множественном наследовании может случиться, что одно и то же поле наследуется по разным путям:

```cpp
struct File{

    int a;
};

struct InputFile : public File{

    int b;
};

struct OutputFile : public File{

    int c;
}

struct IOFile : public InputFile, public OutputFile{

    int d;//поле a унаследовано по двум путям 
};

IOFile f{11};
int x = f.a; //ошибка
int y = f.InputFile::a; //нормально, но в классе все равно лежит два поля а
```

### Виртуальное наследование ###
virtual - аннотация базового класса. Это нужно, чтобы при множественном наслежовании существовал только один экземпляр каждой переменной:

```cpp
struct File{...};
struct InputFile : virtual public File{...};
struct OutputFile : virtual public File{...};
struct IOFile : public InputFile, public OutputFile{...};

IOFile f{11};
int x = f.a; //нормально
int y = f.InputFile::a; //нормально
```

Количество объектов равно сумме всех объектов по невиртуальным путям и одного объекта со всех виртуальных путей.

Для создания виртуального путя достаточно в его начале прописать виртуальное наследование.

### Конструкторы ###
Конструктор самого верхнего базового класса вызываться в самом нижнем дочернем и все вызовы базового конструктора в конструкторах промежуточных классов игнорируются:

```cpp
struct File{
    int a;
    File(int a) : a{a} {}
    virtual ~File() {}
};

struct InputFile : virtual public File{
    int b;
    InputFile(int b) : File(b *2) b{b} {}
};

struct OutputFile : virtual public File{
    int c;
    OutputFile(int c) : File(c * 3), c{c}{}
}

struct IOFile : public InputFile, public OutputFile{
    int d;
    IOFile(int d) : File(d), IputFile(d * 5), Outputfile(d * 7), d{d}{} //в этом месте будет вызван только один конструктор для File от параметра d 
}
```

Поле а базового класса инициализировалось в самом нижнем конструкторе. В остальных классах вызов коснтруктора для File был проигнорирован.

Если мы еще раз отнаследуем класс IOFile новый класс станет нижним и поэтому в нем нужно будет вызвать конструктор класса File.

Сначала конструируются виртуальные подобъекты, а только потом обычные.

### Преобразования ###
При множественном наследовании указатели на производные и базовые классы могут не совпадать, поэтому при приведении к базовому классу надо использовать sttic_cast.

Для каста вверх тоже используется static_cast.

![Картинку украли цыгане](./images/rEu6ozWW3YQ.jpg)

```cpp
struct Filler {//нужно чтобы заполнить своими полями место в объекте класса
    int x, y;
    virtual void filler() = 0; 
    virtual ~Filler() {}
};

struct InputFile{
    int b;
    InputFile(int b) : b{b} {}
    virtual ~InputFile() {}
};

struct OutputFile{
    int c;
    OutputFile(int c) : c{c} {}
    virtual ~OutputFile() {}
};

struct IOFile : public Filler, public InputFile, public OutputFile{
    int d;
    void filler() override {}
    IOFile(int d) : InputFile(d * 2), OutputFile(d *3), d{d} {}
};

IOFile* piof = new IOFile{5};
OutputFile* pof = static_cast<OutputFile*>(piof);//сработает и сдвинет указатель
piof = static_cast<IOFile*>(pof); //сработает и сдвинет указатель
```

При виртуальном наследовании static_cast не работает.

### RTTI ###
RTTI - runtime type information.

Для каждого объекта с хотя бы одной виртуальной функцией во время рантайма хранится его динамический тип. В остальных случаях возвращет статический тип:

```cpp
OutputFile* pof = new IOFile{5};
assert(typeid(*pof) == typeid(IOFile)); //тк у объекта есть динамический тип и он выводится
assert(typeid(pof) != typeid(IOFile*)); //тк у указателя нет динамического типа и выводится статический OutputFile*
```

Оператор typeid возвращает объект std::typeinfo. Этот объект представляет собой динамический или статический тип.

### dynamic_cast ###
dynamic_cast может делать любые преобразования, поскольку поддерживает RTTI и знает динамический тип объекта. Из-за этого сложность выполнения может быть произвольной:

```cpp
IOFile* piof = new IOFile();
File* pf = static_cast<File*>(piof);//каст вниз может работать
InputFile* pif = dynamic_cast<InputFile*>(pf);//каст вверх к промежуточному классу
OutputFile* pof = dynamic_cast<OutputFile*>(pf);
pif = dynamic_cast<InputFile*>(pof); //может переходить на другую ветку наследования
```

В случае неправильного каста dynamic_cast для указателя выдает nullptr. При непраильном касте ссылок он выдает исключение.

### Регулярные выражения ###
Алфавит - множество символов, нпример {a, b, c}

Строка - последовательность символов, например w = aacb.

Конкатенация строк: $w = aacb; z = ba; wz = aacbba; zw = baaacb$

Степень: $w^3 = www; w^0 = \lambda$ 

Этот набор операций создает группу.

Языком над данным алфавитом называется множество его строк: 

$L_{empty} = $ пустое множество строк 

$L_{free} = $ все возможные строки алфавита 

Другие возможные языки:

$ L_1 = \{a^m, b^n \}$ 

$ L_2 = \{a, cab, caabc \}$

$ L_3 = \{a ^n, b^n \}$

$ L_4 = \{a^m b^n c a^m b^n \}$

Задачи над языками:
- принадлежность - является ли строка частью языка
- порождение - создать строки принадлежащие языку
- эквивалентность - выяснить эквивалентны ли два языка друг другу
- отрицание - создатьязык такой, что содержит все строки не принадлежащие данному 

Правила построения языков:
- любой алфавитный символ означает язык
- конкатенация языков $ L_x L_y = \{ wz | w \in L_x \wedge z \in L_y \}$
- дизъюнкция $ L_x + L_y = \{ w | w \in L_x \vee w \in L_y \}$ (множество строчек, принадлежащее обоим языкам)
- замыкание $ (L_x)^* = \{ \{\lambda \}, L_x, L_x L_x, L_x L_x L_x, ... \} $ 

Расширенные символы:

$ a? = a + \lambda \} $ (ноль или одно повторение)

$ a^+ = aa^* $ (одно или больше повторений)

### Регулярные выражения в С++ ###
В них вместо '+' используется '|'.

```cpp
const std::regex r1("(c(a|b)*ab)*ca");

std::cmatch  m;

bool rest1 = std::regex_match("caabca", m, 1); //решает задачу принадлежности
```

### Детерминированный конечный автомат ###
Детерминированным конечным автоматом называют набор состояний и функцию перехода между ними.

### Недетерминированный конечный автомат ###
Для некоторых выражений не понятно когда надо перейти от одного узла к другому. например

$ (a + b)* b (b + c)* $

Для таких случаев существует недетерминированный конечный автомат, в котором некоторы переходы не определны. В таких переходах выполнение автомата разделяется на два и более и если хотя бы один из этих путей ведет к концу, то строчка принадлежит языку.

Алгоритм Рабина -Скотта позволяет перейти от недетерминированного конечного автомата к конечному.

### FLEX ###
Это класс для создания потока лексем из файла с исходным выражением.

Для работы с ним мы создаем файл с правилами:

```cpp
%option c++ 

%{//блок кода 
    using std::cout;
    using std::endl;

%}
//определение алфавитов
WS     [\t\n\v]+
DIGIT  [0-9]
DIGIT1 [1-9]
OP     [\+\=\-]

%%
//правила для работы с ркгулярными выражениями
{WS} //ничего
{OP}                {cout << "operator " << yytext[0] << endl; return 1; }
{DIGIT}{DIGIT1}*    {cout << "number " << yytext << endl; return 1; }
.                   {cout << "UNKNOWN" << endl; return 1; } //правило для всего остального 

%%

//любой код на С++
```

После этого генерируется файл с С++ кодом, в котором есть файл для работы с регулярными выражениями.

### Лемма о накачке ###
Для любого достаточно длинного слова $w$ в регулярном языке найдется такая декомпозиция $w = xyz$, что все слова $xy^nz$ также принадлежат этому языку.

## Лекция 10 ##

### Грамматика ###
Терминальные символы - реальные символы.

Нетерминальные символы - воббражаемый символ, из которого по некоторым правилам можно получить набор терминальныъ символов.

Продукция - замена нетерминального символа на набор символов.

Контекстно свободная грамматика - такой язык, который можно получить продукцией из одного нетерминального символа.

Пример контекстно зависимой грамматики:

$ L_4 = \{ a^m b^n c a^m b^n \}$

Семантические свойства языка - свойства делающие грамматику контекстно зависимой. Изначально все синтаксические деревья строятся на основе контекстно свободной грамматики.

Основные этапы анализа кода:
- Лексические проверки с помощью регулярных выражений (проверяют правильность построения лексем)
- Синтаксические проверки, которые соответствуют контекстно свободным грамматикам
- Семантические проверки(где есть контекстная зависимость)

Левым/правым выводом в грамматике называется стратегия замены либо всегда самого левого нетерминала, либо самого правого.

Левый вывод в грамматике задается синтаксическим деревом.

Если существует несколько выводов одного типа, то грамматика неодназначна.

### Автоматы с магазинной памятью ###
Контекстно свободная грамматика соответствует автоматам с магазинной памятью.

Автомат с магазинной памятью - недетерминированный конечный автомат, к которому добавлен стек.

В зависимости от входных данных автомат заносит в стек А или пушит из него:

![Картинку украли цыгане](./images/automata.png)

### Таксономия L\R ###
Первая буква отвечает за направление сканирования строчки:
L - слева направо 
R - справа налево 

Цифра в скобочках после первой буквы это количество символов, на которые можно заглядывать вперед.

Возможны префиксы, которые обозначают разновидности парсеров.

Вторая буква означает выбранный нетерминал:
- L - берем самый левый 
- R - берем самый правый 

### Рекурсивный спуск ###
LL парсер работает на основе рекурсивного спуска. 

Откат - возвращение наверх, если символ не соответствует грамматике. Необходимо избегать откатов при проектировании грамматике. 

### LL(1) парсер ###
Это рекрсивный спуск без откатов. Условие существования парсера без откатов:
- Для любых двух разных продукций не существуе терминала, который будет два раза в FIRST() множестве этой продукции.
- Не более чем одна из продукций выводит пустую строку(имеет терминальный символ в FOLLOW())
-Продукция В выводит пустую строку, если и только если А не выводит строк из FOLLOW()

FIRST() - множество нетерминальных символов, которые могуь быть первыми при продукции. (если строить синтаксическое дерево, то это будет мнрожество возможных листьев этой продукции)
FOLLOW() - множество элементов, которые могут следовать за этой продукцией.

### LR(k) парсер ###
В Бизоне используется восходящий парсинг.

shift - сдвинуть элемент входного потока в стек.

reduce - использовать продукцию, чтобы изменить содержимое стека на терминал слева от продукции.