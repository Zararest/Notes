# Введение #
Этот документ представляет собой конспект лекций базового курса МФТИ по C++.
---
# Список тем курса #
- Лекция 3
    * Ссылки и указатели
    * lvalue и rvalue
    * using и cdecl
    * Манглирование 
    * Разрешение имен
    * Пространства имен
- Лекция 4
    * Инициалзация
    * Делегация конструкторов
    * RVO
    * Конструктор копирования
    * Квалификации 
    * Пользовательские преобразования
- Лекция 5
    * Владение ресурсами
    * RAI
    * Оператор *
    * Оператор ->
    * rvalue
    * std::move()
    * Аннотация методов
    * Возврат ссылок
    * Конструктор перемещения
    * Реализация std::swap()
    * Правило пяти 
    * Правило нуля

## Лекция 3 ##

### Ссылки и указатели ###
Константные ссылки продлевают время жизни временного объекта. Время жизни таких объектов длится до конца полного выражения. Пример провисания ссылки в структуре:

```cpp
struct S {

    int x;
    const int& y;
};

S x{1, 2}; //ссылка не провисла, потому что был создан постоянный объект на стеке
S* ptr = new S{1, 2}; //ссылка провисла, так как был создан временный объект, и конец полного выражения наступил до присваивания   
```

Возвращение константных ссылок из функций может привести к провисанию. 

### lvalue и rvalue ###
В отличие от lvalue у rvalue нету постоянного места в памяти.

```cpp
int& foo();
foo() = x; //верное выражение, поскольку функция может возвращать ссылку на выделенную память
```

### using и cdecl ###
Чтение типов: идем вправо, затем влево и в конце выходим из скобок. Пример:

```cpp
int *x[20]; //массив указателей на int
int (*y)[20]; //указатель на массив int
int (&z)[20] = *y; //ссылка на массив
```

Для упрощения объявлений используется ключевое слово using:

```cpp
using ptr_to_func_ref = void (*) (int&) //вместо звездочки имя функции

template <typename T>
using ptr_to_func_ref = void (*) (T&); //набор указателей на функцию 
```

### Манглирование ###
Манглирование - процесс искажения имен при переводе языка в ассемблер. При отсутствии манглирования возможно создание API, с помощью которых возможно общение программ на разных языках. 

Из-за гарантии по именам в С невозможно:
1. перегружать функции
2. получать методы классов(структур)
3. получить шаблон 

Для получения стабильного имени в C++ используется:

```cpp
extern "C" double sqrt(double); //для этой функции невозможны перегрузки и namespace
```

### Разрешение имен ###
При разрешении имен выбираются кандидаты, подходящие по сигнатуре. После этого из них выбирается нужный по правилам:
1. Точное совпадение(int -> int; int -> const int&, ...)
2. Точное совпадение с шаблоном(int -> T)
3. Стандартное преобразование(int -> char, float -> unsigned short)
4. Пользовательские преобразования
5. Объекты с переменным числом аргументов
6. Неправильно связанные ссылки

### Пространства имен ###
Пространство имен добавляет манглрование к каждому объекту, входящему в него. Пространство имен можно переоткрывать для добавления туды сущностей:

```cpp
namespace X{
    int foo(); //добавление функции в пространство имен X
}   

using std::vector; //добавление сущности в текущее пространство имен
using namespace X; //добавление всех объектов из X 
```

Анонимные пространства имен

```cpp
namespace { //создался namespace с уникальным именем и сразу был вызван using

    int foo(){

        return 42;
    }
}

int bar() { return foo(); } //внутри текущего модуля можно вызывать foo
```

Правила работы с namespace:
* Не засорять глобальное пространство именем
* Не писать using namespace в заголовочных файлах
* Использовать анонимные пространства имен вместо статических функций(не для классов)
* не использовать анонимные пространства имен в заголовочных файлах

Функция main не манглируется. 

## Лекция 4 ##

### Инициалзация ###
В парсере С++ есть два важных правила:
* Все, что может быть засчитано за объявление функции, является объявлением функции.
* Все, что может считаться обращением к полю, считается обращением к полю.

Пример:

```cpp
struct list_t {}

struct myClass_t {
    int x = 42;

    myClass_t(list_t, list_t){} // конструктор
};

int main(){

    myClass_t m1(list_t(), list_t()); //считается за определение функции
    myClass_t m2{list_t(), list_t()}; //вызов конструктора
}
```

Пример разных видов инициализации:
```cpp
int n; //default-init n = garbage
int m{}; //value-init m = 0
int m = 0;//copy-init

int* p = new int[5]{}; //аналог calloc
```
Для пользовательских классов такие инициализации без параметров одинаковые.

Список инициализации выполняется до тела конструктора. Даже если он пустой, для каждого объекта класса вызывается сначала дефолтнный конструктор или инициализатор, описанный в теле класса. Список инициализации выполняется в том порядке, в котором в классе объявлены поля.

### Делегация конструкторов ###
Если в классе есть несколько нетривиальных конструкторов, то можно вызывать их в списке инициализации других.

```cpp
struct class_c{

    int max = 0, min = 0;

    class_c(int my_max) : max(my_max > 0 ? my_max : DEFAULT_MAX){}

    class_c(int my_max, int my_min) : class_c(my_max), min(42){}
}
```

Делегированный конструктор идет первым в списке инициализации.

### RVO ###
RVO - return value optimizations.

У конструктора копирования и оператора присваивания есть спецсемантика. После выполнения этих функций надо объектами они становятся полностью эквивалентными.

```cpp
foo bar(){ 
    foo local_foo;
    return local_foo;
}

int main(){
    foo f = bar(); //в этом случае не будет вызван оператор присваивания или конструктор копирования
}
```

RVO происходят до оптимизации, поэтому не важно, что происходит в конструкторе копирования и операторе присваивания.

### Конструктор копирования ###
Поскольку конструктор копирования обладает спецсемантикой, у него должна быть одна из форм:

```cpp
struct Copyable{

    Copyable(const Copyable& c);
};
```
Допустимо также принимать неконстантную ссылку, как угодно cv-квалифицированную ссылку или значение.

Конструктор копирования не может быть шаблонным. Пример, когда конструктор копирования будет сгенерирован компилятором: 

```cpp
template <typename T> struct Coercible{

    template <typename U> Coercible(const Coercible<U>& c){} //это не конструктор копирования 
};
```

В этом случае должно быть так:

```cpp
template <typename T> struct Coercible{

    Coercible(const Coercible& c)
};
```

### Квалификации ###
Есть два специальных квалификатора const и volatile
* const - объект не может быть изменен 
* volatile - объект может произвольно измениться между двумя обращениями к нему 
* const volatile - программа не может записать туда значение, но оно может непредсказуемо измениться

### Пользовательские преобразования ###

Можно добавить неявное преобразование типов. Их можно рассматривать как конструкторы. Пример:

```cpp
struct MyString{

    char* buf;
    size_t len;

    MyString(size_t len) : buf_{new char[len]{}, len_{len}} {} //пользовательское преобразование 
};

void foo(MyString);

foo(42); //работает тк было неявное преобразование 
```

Для избежания ненужных неявных преобразований применяется ключевое слово `explicit`.

`explicit` блокирует copy-init:

```cpp
struct Foo{

    explicit Foo(int x){}
};

Foo f{2}; //прямая инициализация сработает
Foo f = 2; //инициализация копированием не сработает 
```

Для преобразований пользовательского класса к другому типу существует оператор преобразования:

```cpp
struct MyString {

    char* buf_; 
    size_t len_;
    
    operator const char*(){ return buf_; } //оператор преобразования из MyString в char* 
};
```

Поскольку может возникнуть конфликт операторов для двух пользовательских классов(в каждом определены пользовательские преобразования в другой), есть разница между copy-init и direct-init:

```cpp
int main(){ 

    Bar b;
    Foo f1{b}; //тут рассматриваются только конструкторы
    Foo f2 = b; //рассматриваются только неявные конструкторы и операторы преобразования
}
```

## Лекция 5 ##

### Владение ресурсами ###
Владеет ресурсом тот, кто его выделяет и освобождает. Пример класса, инвариант которого это владение ресурсом:

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    ScopedPointer(T * ptr = nullptr) : ptr_(ptr){} //этот класс имеет неявное преобразование от обычного указателя к этому
    ~ScopedPointer(){ delete ptr_; }
}
```

Если в каком-то месте необходим ScopePointer, а мы передаем туда обычный указатель, то из-за звездочки рядом с типом будет создан ScopePointer.

### RAI ###
RAI - resource acquisition is initialization(захват ресурса это инициализация).

### Оператор * ###

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    ScopedPointer(T * ptr = nullptr) : ptr_(ptr){}
    ~ScopedPointer(){ delete ptr_; }

    T& operator *(){ return *ptr_; }             //этот оператор может быть только внутри класса
    const T& operator *() const{ return *ptr_; }
}
```

### Оператор -> ###

```cpp
template <typename T> class ScopedPointer{

    T *ptr_;
public:

    T& operator *(){ return *ptr_; }             
    const T& operator *() const{ return *ptr_; }

    T* operator ->(){ return ptr_; } //поскольку этот оператор имеет drill down behavior, этот же оператор будет вызван для T*
    const T* operator  ->() const{ return ptr_; }
}
```

В данном случаем вызов оператора `->` можно представить как:

```cpp
(p.operator ->())->x; //доступ к полю x типа T
```

### rvalue ###
rvalue - само выражение, которое не имеет места в памяти(например х + 1).

Ссылка на rvalue - операция создания объекта со значением выражения.

```cpp
int&& y = x + 1; //сам y является lvalue, но обозначает место в памяти, которое выделилось под выражение
```

Правая ссылка не может быть связана с lvalue:

```cpp
int x = 1;
int&& y = x + 0; //можно
int&& z = x;     //нельзя
```

Неконстантная левая ссылка не может быть связана с rvalue:

```cpp
int& c = x + 1;      //нельзя 
const int& z = x +1; //можно, но это исключение для константной ссылки
```

Сама по себе правая ссылка является lvalue:

```cpp
int&& y = x + 1;
int&& e = y; //нельзя 
int& f = y;  //можно
```

### std::move ###

```cpp
int&& y = std::move(x); //можно воспринимать как простое приведение типов(теперь у одного и того же места в памяти два имени: x, y)
```

Пример работы std::move():

```cpp
ScopePointer y {new int(10)};
ScopePointer b = std::move(y); //тут произошло перемещение состояния из y в b
assert(y == b);              
```

Assert иногда выполнится иногда нет, так как после оператора перемещения временный объект приходит в консистентное непредсказуемое состояние.

После вызова std::move() на y мы можем его переиспользовать и вызывать его методы, потому что знаем, что инвариант класса не нарушен и освобождение пройдет правильно.

### Аннотации методов ###
Поскольку методы можно вызывать от временных объектов, возникают ситуации, когда результат работы этих методов провисает:

```cpp
struct S{

    int n = 0;
    int& access(){ return n; }
};

S x;
int& y =  x.access();
int& z = S{}.access(); //в этом случае ссылка провисла 
```

В данном случае это произошло, потому что у временного объекта закончилось время жизни в конце полного выражения.

Чтобы избежать таких ситуаций существуют аннотации методов:

```cpp
struct S{

    int foo() &;  //может быть вызван только у lvalue объектов 
    int foo() &&; //перегрузка методов по аннотации 
};
```

Для аксессеров надо аннотировать методы:

```cpp
struct S{

    int n = 0;
    int& access() & { return n; }
};

int& z = S{}.access(); //ошибка компиляции 
```

Пример rvalue аннотации:

```cpp
class X{

    vector<char> data_;

public:

    X() = default;
    vector<char> const & data() const & { return data_; }
    vector<char>&& data() && { return std::move(data_); } //в этом случае для временных объектов возвращается временный объект
};
```

### Возврат ссылок ###
Варианты возвращения ссылок:

```cpp
int& foo(int x&){ return x; } //в этом случае не провиснет, но если возвращать ссылку на объект объявленный в функции, то точное провисание
const int& bar(const int& x){ return x; } //если сюда был подан временный объект(bar(x + 1)), то его время жизни продлено на стековом фрейме функции bar(), поэтому провисание 
int&& buz(int&& x){ return std::move(x); } //всегда провисла 
```

Правые ссылки надо возвращать только из && аннотированных методов.

Если из вашего метода возвращается правая ссылка, то вы:
- либо пишите std::move(), std::forward(), std::decl_val()
- либо метод && аннотирован 
- либо вы делаете что-то неправильно 

### Конструктор перемещения ###
Такой конструктор передаёт владение от временного объекта к новому:

```cpp
template <typename T>
class ScopePointer{

    T* ptr_;

public: 

    ScopePointer(const ScopePointer& rhs) : ptr_(new T{*rhs.ptr_}) {} // конструктор копирования(у типа T тоже есть конструктор копирования)
    ScopePointer(ScopePointer&& rhs) : ptr_(rhs.ptr_) { //переместили состояние временного объекта

        rhs.ptr_ = nullptr;
    }
};
```

Аналогично действует перемещающее присваивания. Он оставляет временный объект в консистентном, но необязательно предсказуемом состоянии. 

### Реализация std::swap() ###

```cpp
template <typename T>
void swap(T& x, T& y){

    T tmp = std::move(x);
    x = std::move(y);
    y = std::move(tmp);
}
```

В первой строчке std::move() сделал временный объект, который имеет состояние x. Потом перемещающий оператор присваивания забрал его и поместил в tmp. Аналогично переместились состояния y и tmp.

Если в классе нет перемещающего конструктора, то std::move() привел объект x к временному объекту. Затем вызовется копирующий конструктор, так как это copy-init.

### Правило пяти ###
Если ваш класс требует нетривиального определения(в том числе = delete) хотя бы одного из пяти методов:
1. копирующего конструктора
2. копирующего присваивания
3. перемещающего конструктора
4. перемещающего присваивания
5. деструктора

то нужно нетривиально определить все пять.

### Правило нуля ###
Если ваш класс требует нетривиального определения хотя бы одного из пяти неявных методов, и, таким образом все пять, то в нем не должно быть других методов.

Другими словами Либо класс управляет своей памятью, либо не требует нетривиальных методов.
